<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Bubble Pop</title>
    <!-- Fonts & Icons -->
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        :root {
            --bg-dark: #0f0c29;
            --bg-light: #302b63;
            --ui-glass: rgba(255, 255, 255, 0.15);
            --text-main: #ffffff;
            --accent-pink: #ff007f;
            --accent-cyan: #00f2ff;
            --shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.5);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; }

        body {
            background: linear-gradient(135deg, var(--bg-dark), var(--bg-light), #24243e);
            color: var(--text-main);
            font-family: 'Fredoka', sans-serif;
            overflow: hidden;
            height: 100dvh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        /* --- Game Container --- */
        #game-container {
            position: relative;
            box-shadow: 
                0 0 20px rgba(0, 242, 255, 0.1), /* Glow */
                0 20px 50px rgba(0,0,0,0.6);
            border-radius: 24px;
            overflow: hidden;
            background: rgba(15, 12, 41, 0.8);
            border: 4px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }

        canvas {
            display: block;
            cursor: crosshair;
        }

        /* --- UI Overlay --- */
        .ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
            padding: 20px;
        }

        .header {
            display: flex; justify-content: space-between; align-items: flex-start;
            width: 100%;
        }

        .score-box {
            background: var(--ui-glass);
            padding: 12px 24px;
            border-radius: 50px;
            text-align: center;
            border: 1px solid rgba(255,255,255,0.2);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            min-width: 100px;
        }
        .label { font-size: 0.75rem; text-transform: uppercase; color: #a0a0c0; font-weight: 600; letter-spacing: 1px; }
        .value { font-size: 1.8rem; font-weight: 700; color: #fff; text-shadow: 0 0 10px rgba(255,255,255,0.3); }

        .footer {
            display: flex; justify-content: space-between; align-items: end;
            width: 100%;
        }

        .miss-indicator {
            display: flex; gap: 8px;
            background: rgba(0, 0, 0, 0.4);
            padding: 10px 15px; border-radius: 20px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .orb {
            width: 14px; height: 14px; border-radius: 50%;
            background: #333;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.5);
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        .orb.active {
            background: var(--accent-pink);
            box-shadow: 0 0 10px var(--accent-pink), 0 0 20px var(--accent-pink);
            transform: scale(1.1);
        }

        /* --- Menus --- */
        .overlay {
            position: absolute; top:0; left:0; width:100%; height:100%;
            background: rgba(15, 12, 41, 0.9);
            backdrop-filter: blur(12px);
            display: flex; align-items: center; justify-content: center;
            z-index: 50;
            transition: opacity 0.4s ease;
            opacity: 0; pointer-events: none;
        }
        .overlay.active { opacity: 1; pointer-events: auto; }

        .card {
            background: linear-gradient(145deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05));
            color: white;
            padding: 40px; border-radius: 30px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5), inset 0 1px 1px rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.1);
            max-width: 340px; width: 90%;
            transform: translateY(30px); transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        .overlay.active .card { transform: translateY(0); }

        h1 { 
            font-size: 3.5rem; margin-bottom: 5px; font-weight: 700; line-height: 1;
            background: linear-gradient(to right, var(--accent-cyan), #ffffff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 5px rgba(0,242,255,0.5));
        }
        p { color: #b0b0d0; margin-bottom: 30px; font-weight: 400; font-size: 1.1rem; }

        .btn {
            background: linear-gradient(90deg, var(--accent-pink), #ff5e62);
            color: white;
            border: none; padding: 18px 40px;
            font-size: 1.2rem; font-weight: 700;
            border-radius: 16px; cursor: pointer;
            width: 100%; letter-spacing: 1px;
            box-shadow: 0 10px 20px rgba(255, 0, 127, 0.3);
            transition: all 0.2s;
            text-transform: uppercase;
        }
        .btn:hover { transform: translateY(-3px); box-shadow: 0 15px 30px rgba(255, 0, 127, 0.5); filter: brightness(1.1); }
        .btn:active { transform: translateY(1px); box-shadow: 0 5px 10px rgba(255, 0, 127, 0.3); }

    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        
        <!-- HUD -->
        <div class="ui-layer">
            <div class="header">
                <div class="score-box">
                    <div class="label">Score</div>
                    <div class="value" id="scoreVal">0</div>
                </div>
                <div class="score-box">
                    <div class="label">High</div>
                    <div class="value" id="highVal">0</div>
                </div>
            </div>
            
            <div class="footer">
                <div class="miss-indicator" id="missBox">
                    <div class="orb"></div>
                    <div class="orb"></div>
                    <div class="orb"></div>
                    <div class="orb"></div>
                    <div class="orb"></div>
                </div>
                <!-- Controls hint -->
                <div style="opacity:0.6; font-size:0.9rem; color: var(--accent-cyan); font-weight: 600; text-transform: uppercase; letter-spacing: 1px;">Click to Shoot</div>
            </div>
        </div>

        <!-- Start Menu -->
        <div id="menu" class="overlay active">
            <div class="card">
                <h1>POP<br>BLITZ</h1>
                <p>Clear the neon bubbles!</p>
                <button class="btn" onclick="Game.start()">PLAY NOW</button>
            </div>
        </div>

        <!-- Game Over -->
        <div id="gameover" class="overlay">
            <div class="card">
                <h1 style="font-size: 2.5rem; background: linear-gradient(to right, #ff9966, #ff5e62); -webkit-background-clip: text;">GAME OVER</h1>
                <p>Final Score: <span id="finalScore" style="font-weight:bold; color:white; font-size:1.4rem;">0</span></p>
                <button class="btn" onclick="Game.start()">TRY AGAIN</button>
            </div>
        </div>
        
        <!-- Win Screen -->
        <div id="gamewin" class="overlay">
            <div class="card">
                <h1 style="background: linear-gradient(to right, #56ab2f, #a8e063); -webkit-background-clip: text;">VICTORY!</h1>
                <p>You cleared the board!</p>
                <button class="btn" onclick="Game.start()">PLAY AGAIN</button>
            </div>
        </div>
    </div>

<script>
    /**
     * Audio System (Procedural)
     */
    const AudioSys = {
        ctx: null,
        init() {
            if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        },
        play(type) {
            if (!this.ctx) this.init();
            if (this.ctx.state === 'suspended') this.ctx.resume();
            
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            const t = this.ctx.currentTime;

            osc.connect(gain);
            gain.connect(this.ctx.destination);

            if (type === 'shoot') {
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(300, t);
                osc.frequency.exponentialRampToValueAtTime(600, t + 0.1);
                gain.gain.setValueAtTime(0.2, t);
                gain.gain.linearRampToValueAtTime(0, t + 0.1);
                osc.start(t);
                osc.stop(t + 0.1);
            } else if (type === 'pop') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(800, t);
                osc.frequency.exponentialRampToValueAtTime(100, t + 0.15);
                gain.gain.setValueAtTime(0.2, t);
                gain.gain.linearRampToValueAtTime(0, t + 0.15);
                osc.start(t);
                osc.stop(t + 0.15);
            } else if (type === 'bounce') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(200, t);
                gain.gain.setValueAtTime(0.05, t);
                gain.gain.linearRampToValueAtTime(0, t + 0.05);
                osc.start(t);
                osc.stop(t + 0.05);
            } else if (type === 'drop') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(150, t);
                osc.frequency.linearRampToValueAtTime(50, t + 0.3);
                gain.gain.setValueAtTime(0.1, t);
                gain.gain.linearRampToValueAtTime(0, t + 0.3);
                osc.start(t);
                osc.stop(t + 0.3);
            }
        }
    };

    /**
     * Game Constants & Config
     */
    const CONFIG = {
        cols: 15, // Grid columns
        rows: 20, // Grid rows (visible area)
        radius: 16, // Bubble radius (scaled dynamically)
        // Neon Palette
        colors: ['#ff007f', '#00f2ff', '#bd00ff', '#ffe600', '#00ff41'], 
        missLimit: 5,
        speed: 18 // Faster bullets for snappier feel
    };

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    /**
     * Game State
     */
    const Game = {
        grid: [], // 2D array of {color, x, y, active}
        bullets: [], 
        particles: [], 
        floating: [], 
        
        width: 0, height: 0,
        bubbleDia: 0,
        xOffset: 0,
        
        currentBubble: null,
        nextBubble: null,
        
        angle: -Math.PI / 2, 
        mouseX: 0, mouseY: 0,
        
        score: 0,
        highScore: localStorage.getItem('bubble_high') || 0,
        misses: 0,
        state: 'menu', 
        
        lastTime: 0,

        start() {
            document.querySelectorAll('.overlay').forEach(el => el.classList.remove('active'));
            this.resize();
            this.initGrid();
            this.score = 0;
            this.misses = 0;
            this.bullets = [];
            this.particles = [];
            this.floating = [];
            this.currentBubble = this.randomColor();
            this.nextBubble = this.randomColor();
            this.state = 'playing';
            this.updateUI();
            
            // Input Listeners
            canvas.addEventListener('mousemove', this.handleInput.bind(this));
            canvas.addEventListener('mousedown', this.shoot.bind(this));
            canvas.addEventListener('touchmove', this.handleTouch.bind(this), {passive: false});
            canvas.addEventListener('touchstart', this.handleTouch.bind(this), {passive: false});
            
            requestAnimationFrame(this.loop.bind(this));
        },

        initGrid() {
            this.grid = [];
            // Fill top 6 rows
            for(let r=0; r<CONFIG.rows; r++) {
                this.grid[r] = [];
                for(let c=0; c<CONFIG.cols; c++) {
                    if (r < 6) {
                        this.grid[r][c] = {
                            color: this.randomColor(),
                            active: true
                        };
                    } else {
                        this.grid[r][c] = null;
                    }
                }
            }
        },

        randomColor() {
            return CONFIG.colors[Math.floor(Math.random() * CONFIG.colors.length)];
        },

        resize() {
            const container = document.getElementById('game-container');
            const dpr = window.devicePixelRatio || 1;
            
            let w = window.innerWidth;
            let h = window.innerHeight;
            
            if (w > 600) w = 600;
            if (h > 900) h = 900; 

            container.style.width = w + 'px';
            container.style.height = h + 'px';
            
            canvas.width = w * dpr;
            canvas.height = h * dpr;
            canvas.style.width = w + 'px';
            canvas.style.height = h + 'px';
            
            ctx.scale(dpr, dpr);
            
            this.width = w;
            this.height = h;
            
            this.bubbleDia = this.width / CONFIG.cols;
            CONFIG.radius = this.bubbleDia / 2;
            this.xOffset = 0; 
        },

        handleInput(e) {
            if (this.state !== 'playing') return;
            const rect = canvas.getBoundingClientRect();
            this.mouseX = e.clientX - rect.left;
            this.mouseY = e.clientY - rect.top;
            this.updateAngle();
        },

        handleTouch(e) {
            e.preventDefault();
            if (e.type === 'touchstart') {
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                this.mouseX = touch.clientX - rect.left;
                this.mouseY = touch.clientY - rect.top;
                this.updateAngle();
                this.shoot();
            }
        },

        updateAngle() {
            const shooterX = this.width / 2;
            const shooterY = this.height - CONFIG.radius * 3;
            this.angle = Math.atan2(this.mouseY - shooterY, this.mouseX - shooterX);
            if (this.angle < -Math.PI + 0.2) this.angle = -Math.PI + 0.2;
            if (this.angle > -0.2) this.angle = -0.2;
        },

        shoot() {
            if (this.state !== 'playing' || this.bullets.length > 0) return;
            AudioSys.play('shoot');
            const shooterX = this.width / 2;
            const shooterY = this.height - CONFIG.radius * 3;
            this.bullets.push({
                x: shooterX,
                y: shooterY,
                vx: Math.cos(this.angle) * CONFIG.speed,
                vy: Math.sin(this.angle) * CONFIG.speed,
                color: this.currentBubble
            });
            this.currentBubble = this.nextBubble;
            this.nextBubble = this.randomColor();
        },

        loop(time) {
            const dt = (time - this.lastTime) / 1000;
            this.lastTime = time;
            if (this.state === 'playing') {
                this.update(dt);
                this.draw();
                requestAnimationFrame(this.loop.bind(this));
            }
        },

        update(dt) {
            // Bullets
            for (let i = this.bullets.length - 1; i >= 0; i--) {
                const b = this.bullets[i];
                b.x += b.vx;
                b.y += b.vy;

                // Wall Bounce
                if (b.x - CONFIG.radius < 0) {
                    b.x = CONFIG.radius;
                    b.vx *= -1;
                    AudioSys.play('bounce');
                } else if (b.x + CONFIG.radius > this.width) {
                    b.x = this.width - CONFIG.radius;
                    b.vx *= -1;
                    AudioSys.play('bounce');
                }

                // Ceiling
                if (b.y - CONFIG.radius < 0) {
                    this.snapBubble(b);
                    this.bullets.splice(i, 1);
                    continue;
                }

                // Collision
                if (this.checkCollisionAt(b.x, b.y)) {
                    this.snapBubble(b);
                    this.bullets.splice(i, 1);
                }
            }

            // Particles
            for (let i = this.particles.length - 1; i >= 0; i--) {
                const p = this.particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.5; 
                p.life -= 0.05;
                if (p.life <= 0) this.particles.splice(i, 1);
            }

            // Floating
            for (let i = this.floating.length - 1; i >= 0; i--) {
                const f = this.floating[i];
                f.y += f.vy;
                f.vy += 1; 
                if (f.y > this.height + 50) {
                    this.floating.splice(i, 1);
                    this.addScore(20 * (this.score/1000 + 1));
                }
            }
        },

        checkCollisionAt(x, y) {
            const gridY = Math.floor(y / (this.bubbleDia * 0.866));
            const startRow = Math.max(0, gridY - 2);
            const endRow = Math.min(CONFIG.rows - 1, gridY + 2);

            for (let r = startRow; r <= endRow; r++) {
                for (let c = 0; c < CONFIG.cols; c++) {
                    const g = this.grid[r][c];
                    if (g && g.active) {
                        const dx = x - this.getHexX(r, c);
                        const dy = y - this.getHexY(r, c);
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist < CONFIG.radius * 2 - 6) return true; // -6 for hitbox forgiveness
                    }
                }
            }
            return false;
        },

        snapBubble(b) {
            AudioSys.play('pop');
            let bestDist = Infinity, bestR = 0, bestC = 0;

            for (let r = 0; r < CONFIG.rows; r++) {
                for (let c = 0; c < CONFIG.cols; c++) {
                    if (this.grid[r][c] && this.grid[r][c].active) continue;
                    const gx = this.getHexX(r, c);
                    const gy = this.getHexY(r, c);
                    const dx = b.x - gx, dy = b.y - gy;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < bestDist) { bestDist = dist; bestR = r; bestC = c; }
                }
            }

            if (!this.grid[bestR]) this.grid[bestR] = [];
            this.grid[bestR][bestC] = { color: b.color, active: true };

            const matches = this.findMatches(bestR, bestC, b.color);
            if (matches.length >= 3) {
                this.removeBubbles(matches);
                this.misses = 0;
                this.dropFloating();
                this.addScore(matches.length * 10);
            } else {
                this.misses++;
                if (this.misses >= CONFIG.missLimit) {
                    this.addRow();
                    this.misses = 0;
                }
            }
            this.updateUI();
            this.checkGameOver();
        },

        findMatches(r, c, color) {
            const visited = new Set(), queue = [{r, c}], matches = [];
            while(queue.length > 0) {
                const {r, c} = queue.pop();
                const key = `${r},${c}`;
                if (visited.has(key)) continue;
                visited.add(key);
                if (this.grid[r] && this.grid[r][c] && this.grid[r][c].color === color) {
                    matches.push({r, c});
                    queue.push(...this.getNeighbors(r, c));
                }
            }
            return matches;
        },

        getNeighbors(r, c) {
            const isEven = (r % 2 === 0);
            const candidates = [
                {r: r, c: c-1}, {r: r, c: c+1},
                {r: r-1, c: c}, {r: r-1, c: isEven ? c-1 : c+1},
                {r: r+1, c: c}, {r: r+1, c: isEven ? c-1 : c+1}
            ];
            return candidates.filter(n => n.r >= 0 && n.r < CONFIG.rows && n.c >= 0 && n.c < CONFIG.cols && this.grid[n.r] && this.grid[n.r][n.c] && this.grid[n.r][n.c].active);
        },

        dropFloating() {
            const connected = new Set(), queue = [];
            for(let c=0; c<CONFIG.cols; c++) if (this.grid[0][c] && this.grid[0][c].active) queue.push({r:0, c:c});
            
            while(queue.length > 0) {
                const {r, c} = queue.pop();
                const key = `${r},${c}`;
                if (connected.has(key)) continue;
                connected.add(key);
                queue.push(...this.getNeighbors(r, c));
            }
            
            const drops = [];
            for(let r=0; r<CONFIG.rows; r++) {
                for(let c=0; c<CONFIG.cols; c++) {
                    if (this.grid[r][c] && this.grid[r][c].active && !connected.has(`${r},${c}`)) drops.push({r, c, obj: this.grid[r][c]});
                }
            }
            if (drops.length > 0) {
                AudioSys.play('drop');
                drops.forEach(d => {
                    this.grid[d.r][d.c] = null;
                    this.floating.push({
                        x: this.getHexX(d.r, d.c), y: this.getHexY(d.r, d.c),
                        vx: (Math.random()-0.5) * 2, vy: 0, color: d.obj.color
                    });
                });
            }
        },

        removeBubbles(matches) {
            AudioSys.play('pop');
            matches.forEach(m => {
                const b = this.grid[m.r][m.c];
                const x = this.getHexX(m.r, m.c);
                const y = this.getHexY(m.r, m.c);
                this.createParticles(x, y, b.color);
                this.grid[m.r][m.c] = null;
            });
        },

        createParticles(x, y, color) {
            for(let i=0; i<6; i++) {
                this.particles.push({
                    x: x, y: y,
                    vx: (Math.random() - 0.5) * 12,
                    vy: (Math.random() - 0.5) * 12,
                    life: 1, color: color
                });
            }
        },

        addRow() {
            for(let c=0; c<CONFIG.cols; c++) if (this.grid[CONFIG.rows-2][c]) { this.gameOver(); return; }
            for(let r=CONFIG.rows-1; r>0; r--) this.grid[r] = this.grid[r-1];
            this.grid[0] = [];
            for(let c=0; c<CONFIG.cols; c++) this.grid[0][c] = { color: this.randomColor(), active: true };
        },

        checkGameOver() {
            for(let c=0; c<CONFIG.cols; c++) if (this.grid[16] && this.grid[16][c]) { this.gameOver(); return; }
            let hasBubbles = false;
            for(let r=0; r<CONFIG.rows; r++) for(let c=0; c<CONFIG.cols; c++) if (this.grid[r][c]) hasBubbles = true;
            if (!hasBubbles) this.gameWin();
        },

        gameOver() { this.state = 'gameover'; document.getElementById('gameover').classList.add('active'); document.getElementById('finalScore').innerText = this.score; },
        gameWin() { this.state = 'gamewin'; document.getElementById('gamewin').classList.add('active'); },

        addScore(val) {
            this.score += Math.floor(val);
            if (this.score > this.highScore) { this.highScore = this.score; localStorage.setItem('bubble_high', this.highScore); }
            this.updateUI();
        },

        updateUI() {
            document.getElementById('scoreVal').innerText = this.score;
            document.getElementById('highVal').innerText = this.highScore;
            const orbs = document.querySelectorAll('.miss-indicator .orb');
            orbs.forEach((orb, i) => { if (i < this.misses) orb.classList.add('active'); else orb.classList.remove('active'); });
        },

        getHexX(r, c) { return c * this.bubbleDia + CONFIG.radius + ((r % 2 === 1) ? CONFIG.radius : 0) + this.xOffset; },
        getHexY(r, c) { return r * (this.bubbleDia * 0.866) + CONFIG.radius; },

        draw() {
            ctx.clearRect(0, 0, this.width, this.height);

            // Draw Aiming Line (Bouncing)
            this.drawAimingLine();

            // Grid
            for(let r=0; r<CONFIG.rows; r++) {
                for(let c=0; c<CONFIG.cols; c++) {
                    const b = this.grid[r][c];
                    if (b && b.active) this.drawBubble(this.getHexX(r, c), this.getHexY(r, c), b.color);
                }
            }

            // Floating
            this.floating.forEach(f => this.drawBubble(f.x, f.y, f.color));

            // Current & Next
            const startX = this.width / 2;
            const startY = this.height - CONFIG.radius * 3;
            // Draw next small
            this.drawBubble(startX - 60, startY + 20, this.nextBubble, CONFIG.radius * 0.6);
            // Draw current
            this.drawBubble(startX, startY, this.currentBubble);

            // Bullets
            this.bullets.forEach(b => this.drawBubble(b.x, b.y, b.color));

            // Particles
            this.particles.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life;
                ctx.beginPath();
                ctx.arc(p.x, p.y, CONFIG.radius/2 * p.life, 0, Math.PI*2);
                ctx.fill();
                ctx.globalAlpha = 1;
            });
            
            // Warning Line
            const limitY = this.getHexY(15, 0);
            ctx.beginPath();
            ctx.moveTo(0, limitY);
            ctx.lineTo(this.width, limitY);
            ctx.strokeStyle = 'rgba(255, 0, 127, 0.2)';
            ctx.setLineDash([5, 5]);
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.setLineDash([]);
        },

        drawAimingLine() {
            let simX = this.width / 2;
            let simY = this.height - CONFIG.radius * 3;
            let simVx = Math.cos(this.angle) * 15; // Simulate steps
            let simVy = Math.sin(this.angle) * 15;
            
            ctx.beginPath();
            // Start a bit away from shooter
            ctx.moveTo(simX + simVx * 2, simY + simVy * 2);

            // Simulation loop
            for(let i=0; i<40; i++) { // Limit length for performance/gameplay
                simX += simVx;
                simY += simVy;

                // Wall Bounce
                if (simX - CONFIG.radius < 0) {
                    simX = CONFIG.radius;
                    simVx *= -1;
                } else if (simX + CONFIG.radius > this.width) {
                    simX = this.width - CONFIG.radius;
                    simVx *= -1;
                }
                
                // Stop at top
                if (simY < 0) break;
                
                // Stop at collision
                if (this.checkCollisionAt(simX, simY)) break; 
                
                // Draw dots
                if (i % 2 === 0) {
                    ctx.lineTo(simX, simY);
                } else {
                    ctx.moveTo(simX, simY);
                }
            }
            
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.stroke();
        },

        drawBubble(x, y, color, r = CONFIG.radius) {
            // Main sphere with glow
            ctx.shadowBlur = 10;
            ctx.shadowColor = color;
            
            const grad = ctx.createRadialGradient(x - r*0.3, y - r*0.3, r*0.1, x, y, r);
            grad.addColorStop(0, '#fff'); 
            grad.addColorStop(0.3, color);
            grad.addColorStop(1, this.shadeColor(color, -20)); 

            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(x, y, r - 1, 0, Math.PI*2);
            ctx.fill();
            
            ctx.shadowBlur = 0; // Reset shadow for efficiency

            // Shine
            ctx.fillStyle = 'rgba(255,255,255,0.3)';
            ctx.beginPath();
            ctx.arc(x - r*0.3, y - r*0.3, r*0.25, 0, Math.PI*2);
            ctx.fill();
        },

        shadeColor(color, percent) {
            let R = parseInt(color.substring(1,3),16);
            let G = parseInt(color.substring(3,5),16);
            let B = parseInt(color.substring(5,7),16);
            R = parseInt(R * (100 + percent) / 100);
            G = parseInt(G * (100 + percent) / 100);
            B = parseInt(B * (100 + percent) / 100);
            R = (R<255)?R:255; G = (G<255)?G:255; B = (B<255)?B:255;
            const RR = ((R.toString(16).length==1)?"0"+R.toString(16):R.toString(16));
            const GG = ((G.toString(16).length==1)?"0"+G.toString(16):G.toString(16));
            const BB = ((B.toString(16).length==1)?"0"+B.toString(16):B.toString(16));
            return "#"+RR+GG+BB;
        }
    };

    window.onload = () => Game.resize();
    window.onresize = () => Game.resize();

</script>
</body>
</html>